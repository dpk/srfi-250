<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SRFI 250: Insertion-ordered hash tables</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
      <style>#content > #right > .dose > .dosesingle, #content > #center > .dose > .dosesingle {display:none !important;}
      .content li { margin: 1em 0; }</style></head>
  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI surfboard logo"></a>250: Insertion-ordered hash tables</h1>

<p>by John Cowan and Daphne Preston-Kendal, based on work by Will Clinger and Panu Kalliokoski</p>

<h2 id="status">Status</h2>

<p>This SRFI is currently in <em>draft</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+250+at+srfi+dotschemers+dot+org">srfi-250@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-250/">archive</a>.</p>
<ul>
  <li>Received: 2023-11-13</li>
  <li>Draft #1 published: 2023-11-15</li>
  <li>This SRFI was withdrawn by the editor on 2024-09-24 because
    there had been no progress since 11-2023, when the first draft was
    published, and because he hadn't been able to reach the author,
    John Cowan, since 5-2024, and because no one stepped forward to
    take over.</li>
  <li>John has returned, so the editor moved this SRFI back to draft
    status on 2024-12-05.</li>
  <li>Draft #2 published: 2024-12-05</li>
  <li>Draft #3 published: 2025-06-11</li>
</ul>

<h2 id="abstract">Abstract</h2>

<p>This SRFI defines an interface to hash tables, which are widely
recognized as a fundamental data structure for a wide variety of
applications.  A hash table is a data structure that:</p>

<ul class="content">
  <li>Is disjoint from all other types.</li>
  <li>Provides a mapping from objects known as <dfn>keys</dfn>
    to corresponding objects known as <dfn>values</dfn>.
    <ul>
      <li>Keys may be any Scheme objects in some kinds of hash tables,
        but are restricted in other kinds.</li>
      <li>Values may be any Scheme objects.</li></ul></li>
  <li>Provides an <dfn>equality predicate</dfn> which defines
    when a proposed key is the same as an existing key.  No table
    may contain more than one value for a given key.</li>
  <li>Provides a <dfn>hash function</dfn> which maps a candidate
    key into a non-negative exact integer.</li>
  <li>Supports mutation as the primary means of setting the
    contents of a table.</li>
  <li>Provides key lookup and destructive update in (expected)
    amortized constant time, provided that a satisfactory hash
    function is available.</li>
  <li>Does not guarantee that whole-table operations work in
    the presence of concurrent mutation of the whole hash table.
    (Values may be safely mutated.)</li>
</ul>

<p>Unlike the hash tables
of <a href="https://srfi.schemers.org/srfi-125/">SRFI 125</a>, which
is the direct ancestor of this specification, the hash tables
described here are ordered by insertion: that is, associations
inserted earlier in the history of the hash table appear earlier in
the ordering.  Advances in
the implementations of hash tables, as provided by C++, Python,
JavaScript, etc., make the provision of this new facility practical.
As a result, the hash tables of this SRFI do not interoperate with the
hash tables of SRFI
125, <a href="https://srfi.schemers.org/srfi-126/">SRFI 126</a>, or
existing R6RS implementations.</p>

<h2 id="issues">Issues</h2>

<ul class="content">
  <li>There are no examples.  SRFI 125, upon which this SRFI is based,
    didn't have examples.</li>
  <li>The result in each error case should be more explicitly specified.
</ul>

<h2 id="rationale">Rationale</h2>

<p>
Hash tables themselves don't really need defending: almost all
dynamically typed languages, from awk to JavaScript to Lua to
Perl to Python to Common Lisp, and including many Scheme
implementations, provide them in some form as a fundamental
data structure.  Therefore, what needs to be defended is not
the data structure but the procedures.  This SRFI
supports a great many convenience
procedures on top of the basic hash table interfaces provided
by <a href="https://srfi.schemers.org/srfi-69/">SRFI 69</a>
and
<a href="https://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-14.html">R6RS</a>.
Modulo the question of association ordering,
nothing in it adds power to what those interfaces provide, but
it does add convenience in the form of pre-debugged routines to
do various common things, and even some things not so commonly
done but useful.</p>

<p>
There is no support for thread safety or weakness.</p>

<p>
This specification depends on
<a href="https://srfi.schemers.org/srfi-128/">SRFI 128</a>
comparators, which package a type test, an equality predicate, and a
hash function into a single bundle.</p>

<p>
The relatively few hash table procedures in R6RS are all available
in this SRFI under somewhat different names.
This SRFI adopts SRFI 69's spelling <code>hash-table</code>
rather than R6RS's <code>hashtable</code>, because of the universal
use of "hash table" rather than "hashtable" in other computer languages and
in technical prose generally.  Besides, the English word
<i>hashtable</i> obviously means something that can be ... hashted.
It would be trivial to provide the R6RS names on top of this SRFI.</p>

<h3 id="CommonLispcompatibility">Common Lisp compatibility</h3>

<p>
As usual, the Common Lisp names are completely different from the
Scheme names. Common Lisp provides the following capabilities that
are not in this SRFI:</p>

<ul class="content">
  <li>The constructor allows specifying the rehash size and
    rehash threshold of the new hash table.  There are also accessors
    and mutators for these and for the current capacity (as opposed to
    size).</li>
  <li>There are hash tables based on <code>equalp</code>
    (which does not exist in Scheme).</li>
  <li><code>With-hash-table-iterator</code> is a hash
    table external iterator implemented as a local macro.</li>
  <li><code>Sxhash</code> is an implementation-specific
    hash function for the <code>equal</code> predicate.
    It has the property that objects in different instantiations
    of the same Lisp implementation that are
    <a href="https://www.lispworks.com/documentation/HyperSpec/Body/03_bdbb.htm">similar</a>
    (a concept analogous to <code>equal</code> but defined across all
    instantiations of a Common Lisp program)
    always return the same value from <code>sxhash</code>; for example,
    the symbol
    <code>xyz</code> will have the same <code>sxhash</code> result in
    all instantiations.</li>
</ul>

<h3 id="Sources">Sources</h3>

<p>
The procedures in this SRFI are drawn primarily from SRFI 69 and R6RS.
In addition, the following sources are acknowledged:</p>

<ul class="content">
  <li>The <code>hash-table-mutable?</code> procedure and the
    second argument of <code>hash-table-copy</code> (which allows
    the creation of immutable hash tables) are from R6RS, renamed
    in the style of this SRFI.</li>
  <li>The <code>hash-table-intern!</code> procedure is from
    <a href="https://docs.racket-lang.org/reference/hashtables.html">Racket</a>,
    renamed in the style of this SRFI.</li>
  <li>The <code>hash-table-find</code> procedure is a modified
    version of <code>table-search</code> in
    <a href="https://gambitscheme.org/4.8.7/manual/#Definition_of_table-search">Gambit</a>.</li>
  <li>The procedures <code>hash-table-unfold</code> and
    <code>hash-table-count</code> were suggested by
    <a href="https://srfi.schemers.org/srfi-1/">SRFI 1</a>.  </li>
  <li>The procedures <code>hash-table=</code> and
    <code>hash-table-map</code> were suggested by
    <a href="https://hackage.haskell.org/package/containers-0.5.2.1/docs/Data-Map-Strict.html">Haskell's Data.Map.Strict module</a>.</li>
  <li>The procedure <code>hash-table-map-&gt;list</code> is from
    <a href="https://www.gnu.org/software/guile/manual/html_node/Hash-Table-Reference.html">Guile</a>.</li>
  <li>The cursor-based interface to hash table iteration is based
    on the version from
    <a href="https://docs.racket-lang.org/reference/hashtables.html#%28def._%28%28quote._~23~25kernel%29._hash-iterate-first%29%29">Racket</a>.</li>
</ul>

<p>
The procedures <code>hash-table-empty?</code>,
<code>hash-table-empty-copy</code>, <code>hash-table-pop!</code>,
<code>hash-table-map!</code>, <code>hash-table-intersection!</code>,
<code>hash-table-difference!</code>, and <code>hash-table-xor!</code>
were added for convenience and completeness.</p>

<p>
The native hash tables of
<a href="https://www.gnu.org/software/mit-scheme/documentation/stable/mit-scheme-ref/Hash-Tables.html">MIT</a>,
<a href="https://sisc-scheme.org/manual/html/ch09.html#Hashtables">SISC</a>,
<a href="https://www-sop.inria.fr/indes/fp/Bigloo/doc/bigloo-7.html#Hash-Tables">Bigloo</a>,
<a href="https://www.s48.org/0.57/manual/s48manual_44.html">Scheme48</a>,
<a href="https://people.csail.mit.edu/jaffer/SLIB.html">SLIB</a>,
<a href="https://web.archive.org/web/20190604155540/http://www.rscheme.org/rs/b/0.7.3.4/5/html/c2143.html">RScheme</a>,
<a href="https://ccrma.stanford.edu/software/snd/snd/s7.html#hashtables">Scheme 7</a>,
<a href="https://github.com/barak/scheme9/blob/master/lib/hash-table.scm">Scheme 9</a>,
<a href="https://web.archive.org/web/20060103123743/http://www.fifi.org/cgi-bin/info2www?(librep)Hash+Tables">Rep</a>,
and <a href="https://code.google.com/archive/p/femtolisp/wikis/APIReference.wiki">FemtoLisp</a>
were also investigated, but no additional procedures were incorporated.</p>

<p>The <code>hash-table-keys</code>, <code>hash-table-values</code>,
<code>hash-table-entries</code> (from SRFI 69) and the corresponding
vector-based versions (used in R6RS) have been removed from this SRFI
in favour of the cursor-based iteration interface.

<h3 id="Pronunciation">Pronunciation</h3>

<p>
The slash in the names of some procedures can be pronounced ‘with’.</p>

<h3 id="editorial-conventions">Editorial conventions</h3>

<p>
This SRFI uses a convention from the Racket documentation, which
extends the usual Scheme specification use of ellipsis (‘...’) in
procedure entry headers.

<p>
Namely, when two specified formals are followed by a pair of ellipses,
it means there must be any even number of arguments in sequence
(including zero arguments). The zeroth, second, fourth, etc. actual
arguments are treated as the values of the first specified formal, and
the first, third, fifth, etc. actual arguments as the corresponding
values of the second of the specified formals.

<h2 id="specification">Specification</h2>

<p>
The procedures in this SRFI are in the <code>(srfi 250)</code> library
(or <code>(srfi :250 hash-tables)</code> on R6RS).</p>

<p>
All references to ‘executing in expected amortized constant time’
presuppose that a satisfactory hash function is available. <span
title="dpk disclaims all responsibility for this joke">Arbitrary or
impure hash functions can make a hash of any
implementation.</span></p>

<p>
Hash tables are allowed to cache the results of calling the equality
predicate and hash function, so programs cannot rely on the hash
function being called exactly once for every primitive hash table
operation: it may be called zero, one, or more times.</p>

<p>
It is undefined behaviour if the procedure argument of
<code>hash-table-find</code>, <code>hash-table-count</code>,
<code>hash-table-map</code>, <code>hash-table-for-each</code>,
<code>hash-table-map!</code>, <code>hash-table-map-&gt;list</code>,
<code>hash-table-fold</code>, <code>hash-table-fold-left</code>,
<code>hash-table-fold-right</code>, or <code>hash-table-prune!</code>
mutates the hash table being walked.</p>

<p>
It is an error to pass two hash tables that have different (in the
sense of <code>eq?</code>) comparators to any of the procedures of
this SRFI.</p>

<p>
Implementations are permitted to ignore user-specified hash
functions in certain circumstances.  Specifically, if the
equality predicate, whether passed as part of a comparator
or explicitly, is more fine-grained (in the sense of R7RS-small
section 6.1) than <code>equal?</code>, the implementation is
free — indeed, is encouraged — to ignore the user-specified
hash function and use something implementation-dependent.
This allows the use of addresses as hashes, in which case
the keys must be rehashed if they are moved by the garbage
collector.  Such a hash function is unsafe to use outside
the context of implementation-provided hash tables.  It can
of course be exposed by an implementation as an extension,
with suitable warnings against inappropriate uses.</p>

<p>It is undefined behaviour to mutate a key during or after its
insertion into a hash table in such a way that the hash function of
the table will return a different result when applied to that key.</p>

<h3 id="Index">Index</h3>
<ul class="content">
  <li><a class="wiki" href="#Constructors">Constructors</a>:
    <code>make-hash-table</code>,
    <code>hash-table</code>,
    <code>hash-table-unfold</code>,
    <code>alist-&gt;hash-table</code>
  </li>
  <li><a class="wiki" href="#Predicates">Predicates</a>:
    <code>hash-table?</code>,
    <code>hash-table-contains?</code>,
    <code>hash-table-empty?</code>,
    <code>hash-table=?</code>,
    <code>hash-table-mutable?</code>
  </li>
  <li><a class="wiki" href="#Accessors">Accessors</a>:
    <code>hash-table-ref</code>,
    <code>hash-table-ref/default</code>,
    <code>hash-table-comparator</code>
  </li>
  <li><a class="wiki" href="#Mutators">Mutators</a>:
    <code>hash-table-add!</code>,
    <code>hash-table-replace!</code>,
    <code>hash-table-set!</code>,
    <code>hash-table-delete!</code>,
    <code>hash-table-intern!</code>,
    <code>hash-table-update!</code>,
    <code>hash-table-update!/default</code>,
    <code>hash-table-pop!</code>,
    <code>hash-table-clear!</code>
  </li>
  <li><a class="wiki" href="#Thewholehashtable">The whole hash table</a>:
    <code>hash-table-size</code>,
    <code>hash-table-keys</code>,
    <code>hash-table-values</code>,
    <code>hash-table-entries</code>,
    <code>hash-table-key-vector</code>,
    <code>hash-table-value-vector</code>,
    <code>hash-table-entry-vectors</code>,
    <code>hash-table-keys</code>,
    <code>hash-table-values</code>,
    <code>hash-table-entries</code>,
    <code>hash-table-find</code>,
    <code>hash-table-count</code>
  </li>
  <li><a class="wiki" href="#Mappingandfolding">Mapping and
      folding</a>:
    <code>hash-table-map</code>,
    <code>hash-table-for-each</code>,
    <code>hash-table-map!</code>,
    <code>hash-table-map-&gt;list</code>,
    <code>hash-table-fold</code>,
    <code>hash-table-fold-left</code>,
    <code>hash-table-fold-right</code>,
    <code>hash-table-prune!</code>
  </li>
  <li><a class="wiki" href="#Lowleveliteration">Low-level
    iteration</a>:
    <code>hash-table-cursor-first</code>,
    <code>hash-table-cursor-last</code>,
    <code>hash-table-cursor-next</code>,
    <code>hash-table-cursor-previous</code>,
    <code>hash-table-cursor-key</code>,
    <code>hash-table-cursor-value</code>,
    <code>hash-table-cursor-key+value</code>,
    <code>hash-table-cursor-at-end?</code>
  <li><a class="wiki" href="#Copyingandconversion">Copying and conversion</a>:
    <code>hash-table-copy</code>,
    <code>hash-table-empty-copy</code>,
    <code>hash-table-&gt;alist</code>
  </li>
  <li><a class="wiki" href="#Hashtablesassets">Hash tables as sets</a>:
    <code>hash-table-union!</code>,
    <code>hash-table-intersection!</code>,
    <code>hash-table-difference!</code>,
    <code>hash-table-xor!</code>
  </li>
</ul>

<h3 id="Constructors">Constructors</h3>

<p>Note that the argument <var>k</var> is a nonnegative integer
representing the initial capacity of the hashtable being created (that
is, the number of associations it can hold without having to grow). If
not present, the initial capacity is implementation-dependent. An
implementation may be significantly more efficient in time and/or
memory if it is a correct value of <var>k</var> when a hash table is
created (meaning a value which actually corresponds to the maximum
size of the hash table throughout its existence).
</p>

<h4>
  <code>(make-hash-table </code><var>comparator</var><code>)</code> <br>
  <code>(make-hash-table </code><var>comparator</var> <var>k</var><code>)</code>
</h4>

<p>
Returns a newly allocated hash table whose equality predicate and
hash function are extracted from <var>comparator</var>.</p>

<p>
It is an assertion violation if <var>comparator</var> is not a hash comparator.

<p>
As mentioned above, implementations are free to use an appropriate
implementation-dependent hash function instead of the
specified hash function, provided that the specified equality predicate
is a refinement of the <code>equal?</code> predicate.
This applies whether the hash function and equality predicate are passed
as separate arguments or packaged up into a comparator.</p>

<p>
The constraints on equality predicates and hash functions are given in
<a href="https://srfi.schemers.org/srfi-128/">SRFI 128</a>.</p>

<p>
(R6RS <code>make-eq-hashtable</code>, <code>make-eqv-hashtable</code>,
and <code>make-hashtable</code>; Common Lisp <code>make-hash-table</code>)</p>

<h4>
  <code>(hash-table </code><var>comparator</var> <var>key</var><sub>0</sub> <var>value</var><sub>0</sub> ... ...<code>)</code>
</h4>

<p>
Returns a newly allocated hash table, created as if by
<code>make-hash-table</code> using <var>comparator</var>.
For each pair of arguments, an association is added to the
new hash table with <var>key</var> as its key and <var>value</var>
as its value.

<p>
It is an assertion violation if any of the <var>key</var>s do not
satisfy the type test of the <var>comparator</var>. If any of the
<var>key</var>s are the same as one another in the sense of the
<var>comparator</var>’s hash function and equality predicate, it is
unspecified whether it is an assertion violation, or if an arbitrary
one of the <var>value</var>s of those <var>key</var>s will appear in the
returned hash table.

<h4>
  <code>(hash-table-unfold </code><var>stop?</var> <var>mapper</var> <var>successor</var> <var>seed</var> <var>comparator</var><code>)</code> <br>
  <code>(hash-table-unfold </code><var>stop?</var> <var>mapper</var> <var>successor</var> <var>seed</var> <var>comparator</var> <var>k</var><code>)</code>
</h4>

<p>
Create a new hash table as if by <code>make-hash-table</code> using
<var>comparator</var> (and, if given, the value of <var>k</var>). If
the result of applying the predicate <var>stop?</var> to <var>seed</var>
is true, return the hash table. Otherwise, apply the procedure
<var>mapper</var> to <var>seed</var>. <var>Mapper</var> returns two values,
which are inserted into the hash table as the key and the value
respectively. Then get a new seed by applying the procedure
<var>successor</var> to <var>seed</var>, and repeat this algorithm.

<p>
This procedure may not be continuation-safe.

<h4>
  <code>(alist-&gt;hash-table </code><var>alist</var> <var>comparator</var><code>)</code> <br>
  <code>(alist-&gt;hash-table </code><var>alist</var> <var>comparator</var> <var>k</var><code>)</code>
</h4>

<p>
Returns a newly allocated hash-table as if by
<code>make-hash-table</code> using <var>comparator</var> and the
optional <var>k</var> value. It is then initialized from the
associations of <var>alist</var>. Key-value pairings are stored in the
created hash table in reverse order to the one in which they appear
in the input <var>alist</var>, and associations earlier in the list take
precedence over those that come later.</p>

<h3 id="Predicates">Predicates</h3>

<h4>
 <code>(hash-table? </code><var>obj</var><code>)</code>
</h4>

<p>
Returns <code>#t</code> if <var>obj</var> is a hash table, and
<code>#f</code> otherwise.  (R6RS <code>hashtable?</code>;
Common Lisp <code>hash-table-p</code>)</p>

<h4>
<code>(hash-table-contains? </code><var>hash-table</var> <var>key</var><code>)</code>
</h4>

<p>Returns <code>#t</code> if there is any association to <var>key</var>
in <var>hash-table</var>, and <code>#f</code> otherwise.  Must execute
in expected amortized constant time.
(R6RS <code>hashtable-contains?</code>)</p>

<h4>
<code>(hash-table-empty? </code><var>hash-table</var><code>)</code>
</h4>

<p>
Returns <code>#t</code> if <var>hash-table</var> contains no associations,
and <code>#f</code> otherwise.</p>

<h4>
  <code>(hash-table= </code><var>same?</var> <var>hash-table</var><sub>1</sub> <var>hash-table</var><sub>2</sub><code>)</code>
</h4>

<p>
Returns <code>#t</code> if <var>hash-table</var><sub>1</sub> and
<var>hash-table</var><sub>2</sub> have the same keys (in the sense
of their common equality predicate) and each key has the same
value (in the sense of the <var>same?</var> procedure), and
<code>#f</code> otherwise.</p>

<p>
It is an assertion violation if the equality predicates of
<var>hash-table</var><sub>1</sub> and <var>hash-table</var><sub>2</sub>
are not the same in the sense of the <code>eqv?</code> procedure. On
R6RS implementations where <code>eqv?</code> is not usefully defined
on procedures by the implementation, this assertion violation is not
required to be raised.

<h4>
  <code>(hash-table-mutable? </code><var>hash-table</var><code>)</code>
</h4>

<p>
Returns <code>#t</code> if the hash table is mutable.
(R6RS <code>hashtable-mutable?</code>)</p>

<h3 id="Accessors">Accessors</h3>

<p>
The following procedures, given a key, return the corresponding value.</p>

<h4>
  <code>(hash-table-ref </code><var>hash-table</var> <var>key</var><code>)</code> <br>
  <code>(hash-table-ref </code><var>hash-table</var> <var>key</var> <var>failure</var><code>)</code> <br>
  <code>(hash-table-ref </code><var>hash-table</var> <var>key</var> <var>failure</var> <var>success</var><code>)</code>
</h4>

<p>
Extracts the value associated to <var>key</var> in <var>hash-table</var>,
invokes the procedure <var>success</var> on it, and returns its result;
if <var>success</var> is not provided, then the value itself is returned.
If <var>key</var> is not contained in <var>hash-table</var> and
<var>failure</var> is supplied, then <var>failure</var> is invoked
on no arguments and its result is returned.  Otherwise, it is
an error.  Must execute in expected amortized constant time,
not counting the time to call the procedures.</p>

<h4>
  <code>(hash-table-ref/default </code><var>hash-table</var> <var>key</var> <var>default</var><code>)</code>
</h4>

<p>
Semantically equivalent to, but may be more efficient than, the following code:</p>
<blockquote>

<p>
<code>(hash-table-ref </code><var>hash-table</var> <var>key</var> <code>(lambda () </code><var>default</var><code>))</code></p>
</blockquote>

<p>
(R6RS <code>hashtable-ref</code>; Common Lisp <code>gethash</code>)</p>

<h4>
  <code>(hash-table-comparator </code><var>hash-table</var><code>)</code>
</h4>

<p>
Returns a hash comparator whose equality function and hash function
are equivalent to the ones of the comparator provided when the hash
table was constructed.

<p>
It is unspecified whether the returned comparator includes a type test
function or ordering predicate. The returned comparator object may or
may not be the same (in the sense of <code>eqv?</code>) as the
comparator which was provided when the hash table was constructed.

<p>
<i>Rationale:</i> An implementation may wish to extract the hash and
equivalence functions from a comparator and store them directly,
rather than indirectly through the comparator. If it did so, it would
have no reason to also store the ordering predicate and may not need
to store the type test either. But it would be impossible to implement
the R6RS <code>(rnrs hashtables (6))</code> library in terms of this
library without a means of inspection.

<h3 id="Mutators">Mutators</h3>

<p>
The following procedures alter the associations in a hash table
either unconditionally or conditionally on the presence or absence
of a specified key.  It is an error to add an association to a hash
table whose key does not satisfy the type test predicate of the
comparator used to create the hash table.</p>

<h4>
  <code>(hash-table-add! </code><var>hash-table</var> <var>key</var><sub>1</sub> <var>value</var><sub>1</sub> ... ...<code>)</code>
</h4>

<p>
Repeatedly mutates <var>hash-table</var>, creating new associations in
it by processing the arguments from left to right. For each of the
pairs of <var>key</var>s and <var>value</var>s, a new entry is created at
the end of the hash table ordering, associating the <var>key</var> with
the <var>value</var>.

<p>
It is an assertion violation if any of the <var>key</var>s is already
associated to an entry in the <var>hash-table</var>. It is also an
assertion violation if any of the <var>key</var>s do not satisfy the
type test of the <var>hash-table</var>’s comparator. It is unspecified
whether any of the other associations of <var>key</var>s to
<var>value</var>s will have been added before the assertion violation is
raised.
 
<h4>
  <code>(hash-table-replace! </code><var>hash-table</var> <var>key</var><sub>1</sub> <var>value</var><sub>1</sub> ... ...<code>)</code>
</h4>

<p>
Repeatedly mutates <var>hash-table</var>, replacing the value in each
entry for the given <var>key</var> with the corresponding
<var>value</var>.

<p>
It is an assertion violation if any of the <var>key</var>s does not have
an association in the <var>hash-table</var>. It is also an assertion
violation if any of the <var>key</var>s do not satisfy the type test of
the <var>hash-table</var>’s comparator. It is unspecified whether the
values for any of the other <var>key</var>s will have been modified
before the assertion violation is raised.

<h4>
  <code>(hash-table-set! </code><var>hash-table</var> <var>key</var><sub>1</sub> <var>value</var><sub>1</sub> ... ...<code>)</code>
</h4>

<p>
Repeatedly mutates <var>hash-table</var>, creating new associations in
it by processing the arguments from left to right. Newly created
associations are added to the end of the hash table ordering. However,
if there is a previous association for any <var>key</var>, its value is
updated to the given <var>value</var> and the corresponding association
remains in the same position in the ordering. Must execute in expected
amortized constant time per key. R6RS <code>hashtable-set!</code> and
Common Lisp <code>(setf gethash)</code> do not handle multiple
associations.</p>

<p>
<i>Note:</i> The <code>hash-table-add!</code> and
<code>hash-table-replace!</code> procedures should often be used in
preference to this procedure, in order to more faithfully represent
the expectation either that a new entry will be created for each
<var>key</var>, or that each <var>key</var> will already have an extant
entry. In cases where an ‘upsert’ operation is intended, the
<code>hash-table-intern!</code> and <code>hash-table-update!</code>
procedures are also often more expressive than the equivalent
operation expressed directly in terms of <code>hash-table-set!</code>.

<h4>
  <code>(hash-table-delete! </code><var>hash-table</var> <var>key</var> ...<code>)</code>
</h4>

<p>
Deletes any association to each <var>key</var> in <var>hash-table</var>
and returns the number of keys that had associations.  Must execute
in expected amortized constant time per key.

<p>
If any of the <var>key</var>s do not satisfy the type test of the
<var>hash-table</var>’s comparator, it is an assertion violation. It is
unspecified whether any of the associations of the other <var>key</var>s
will already have been deleted before the assertion violation is raised.

<p>
R6RS <code>hashtable-delete!</code> and Common Lisp
<code>remhash</code> do not handle multiple associations.</p>

<h4>
  <code>(hash-table-intern! </code><var>hash-table</var> <var>key</var> <var>failure</var><code>)</code>
</h4>

<p>
Effectively invokes <code>hash-table-ref</code> with the given
arguments and returns what it returns. If <var>key</var> was not found
in <var>hash-table</var>, its value is set to the result of calling
<var>failure</var> and that value is returned. Must execute in expected
amortized constant time.</p>

<h4>
  <code>(hash-table-update! </code><var>hash-table</var> <var>key</var> <var>updater</var><code>)</code> <br>
  <code>(hash-table-update! </code><var>hash-table</var> <var>key</var> <var>updater</var> <var>failure</var><code>)</code> <br>
  <code>(hash-table-update! </code><var>hash-table</var> <var>key</var> <var>updater</var> <var>failure</var> <var>success</var><code>)</code>
</h4>

<p>
Semantically equivalent to, but may be more efficient than, the following code:</p>
<blockquote>

<p>
<code>(hash-table-set! </code><var>hash-table</var> <var>key</var><code> (</code><var>updater</var> <code>(hash-table-ref </code><var>hash-table</var> <var>key</var> <var>failure</var> <var>success</var><code>)))</code></p>
</blockquote>

<p>
Must execute in expected amortized constant time.  Returns an unspecified value.</p>

<h4>
  <code>(hash-table-update!/default </code><var>hash-table</var> <var>key</var> <var>updater</var> <var>default</var><code>)</code>
</h4>

<p>
Semantically equivalent to, but may be more efficient than, the following code:</p>
<blockquote>

<p>
<code>(hash-table-set! </code><var>hash-table</var> <var>key</var><code> (</code><var>updater</var> <code>(hash-table-ref/default </code><var>hash-table</var> <var>key</var> <var>default</var><code>)))</code></p>
(R6RS <code>hashtable-update!</code>)
</blockquote>

<p>
Must execute in expected amortized constant time.  Returns an unspecified value.</p>

<h4>
  <code>(hash-table-pop! </code><var>hash-table</var><code>)</code>
</h4>

<p>
Chooses the last, most recently added association from
<var>hash-table</var> and removes it, returning the key and value as two
values.</p>

<p>
It is an assertion violation if <var>hash-table</var> is empty.</p>

<h4>
  <code>(hash-table-clear! </code><var>hash-table</var><code>)</code>
</h4>
<p>
Delete all the associations from <var>hash-table</var>.
(R6RS <code>hashtable-clear!</code>; Common Lisp <code>clrhash</code>)</p>

<h3 id="Thewholehashtable">The whole hash table</h3>

<p>
These procedures process the associations of the hash table
in insertion order.</p>

<h4>
  <code>(hash-table-size </code><var>hash-table</var><code>)</code>
</h4>

<p>
Returns the number of associations in <var>hash-table</var> as an
exact integer.  Must execute in constant time.
(R6RS <code>hashtable-size</code>; Common Lisp <code>hash-table-count</code>.)</p>

<h4>
  <code>(hash-table-find </code><var>proc hash-table failure</var><code>)</code>
</h4>

<p>
For each association of <var>hash-table</var>, invoke <var>proc</var>
on its key and value.   If <var>proc</var> returns true, then
<code>hash-table-find</code> returns what <var>proc</var> returns.
If all the calls to <var>proc</var> return <code>#f</code>, return
the result of invoking the thunk <var>failure</var>.</p>

<h4>
  <code>(hash-table-count </code><var>pred</var> <var>hash-table</var><code>)</code>
</h4>

<p>
For each association of <var>hash-table</var>, invoke <var>pred</var>
on its key and value.  Return the number of calls to <var>pred</var>
which returned true.</p>

<h3 id="Lowleveliteration">Low-level iteration</h3>

<p>
This section introduces the <dfn>hash table cursor</dfn>, a low-level
mechanism for iterating over the associations in a hash table.

<p>
A hash table cursor is a Scheme object of an unspecified type, not
guaranteed to be disjoint from any other Scheme type. It represents a
particular key-value association within a hash table, and the ability
to find a new cursor representing the association which comes
immediately before or after that in the list associations. A hash
table cursor can also be in an end state, in which case it does not
represent any key-value association. Any given hash table cursor has
limits on its spatial and temporal validity:

<ul>
<li>Spatial limitation: a hash table cursor object can only be used in
        combination with the hash table object for which it was
        created.
<li>Temporal limitation: a hash table cursor object can only be used
        as long as no associations in the hash table have been created,
        deleted, or moved since the operation which returned that cursor
        object.
</ul>

<p>
It is undefined behaviour to use a hash table cursor in any way which
violates these limitations.

<h4>
<code>(hash-table-cursor-first </code><var>hash-table</var><code>)</code>
<br>
<code>(hash-table-cursor-last </code><var>hash-table</var><code>)</code>
</h4>

<p>
Return a hash table cursor pointing, respectively, at the first or
last association in the given <var>hash-table</var>.

<h4>
<code>(hash-table-cursor-next </code><var>hash-table</var> <var>cursor</var><code>)</code>
</h4>

<p>
Returns a hash table cursor pointing to the association in the given
<var>hash-table</var> which comes immediately after the association
referred to by the input <var>cursor</var>.

<p>
If the given <var>cursor</var> refers to the last association in the
hash table, the returned hash table cursor is in the end state.

<p>
If the given <var>cursor</var> is already in the end state, it is
undefined behaviour.

<h4>
<code>(hash-table-cursor-previous </code><var>hash-table</var> <var>cursor</var><code>)</code>
</h4>

<p>
Returns a hash table cursor pointing to the association in the given
<var>hash-table</var> which comes immediately before the association
referred to by the input <var>cursor</var>.

<p>
If the given <var>cursor</var> refers to the first association in the
hash table, the returned hash table cursor is in the end state.

<p>
If the given <var>cursor</var> is already in the end state, it is
undefined behaviour.

<h4>
<code>(hash-table-cursor-key </code><var>hash-table</var> <var>cursor</var><code>)</code>
<br>
<code>(hash-table-cursor-value </code><var>hash-table</var> <var>cursor</var><code>)</code>
</h4>

<p>
Return, respectively, the key or value of the association in the
<var>hash-table</var> to which the given <var>cursor</var> refers.

<p>
If the given <var>cursor</var> is in the end state, it is undefined
behaviour.

<h4>
<code>(hash-table-cursor-key+value </code><var>hash-table</var> <var>cursor</var><code>)</code>
</h4>

<p>
Returns two values: the key and value of the association in the
<var>hash-table</var> to which the given <var>cursor</var> refers.

<p>
If the given <var>cursor</var> is already in the end state, it is
undefined behaviour.

<h4>
<code>(hash-table-cursor-at-end? </code><var>hash-table</var> <var>cursor</var><code>)</code>
</h4>

<p>
Returns <code>#t</code> if the given <code>cursor</code> is in the end
state in the given <code>hash-table</code>, and <code>#f</code> otherwise.

<h3 id="Mappingandfolding">Mapping and folding</h3>

<p>
These procedures process the associations of the hash table in
insertion order.</p>

<h4>
  <code>(hash-table-map </code><var>proc</var> <var>hash-table</var><code>)</code>
</h4>

<p>
Returns a newly allocated hash table as if by
<code>(hash-table-empty-copy </code><var>hash-table</var><code>)</code>.
Calls <var>proc</var> for every association in <var>hash-table</var>
with the key and value of the association.  The key of the association
and the result of invoking <var>proc</var> are entered into the
new hash table.  Note that this is <em>not</em> the result of
lifting mapping over the domain of hash tables, but it is
considered more useful.</p>

<p>If <var>comparator</var> recognizes multiple keys in the <var>hash-table</var>
as equivalent, any one of such associations is taken.</p>

<h4>
  <code>(hash-table-for-each </code><var>proc</var> <var>hash-table</var><code>)</code>
</h4>

<p>
Calls <var>proc</var> for every association in <var>hash-table</var>
with two arguments: the key of the association and the value of
the association.  The value returned by <var>proc</var> is discarded.
Returns an unspecified value.</p>

<h4>
  <code>(hash-table-map! </code><var>proc</var> <var>hash-table</var><code>)</code>
</h4>

<p>
Calls <var>proc</var> for every association in <var>hash-table</var>
with two arguments: the key of the association and the value of
the association.  The value returned by <var>proc</var> is used to
update the value of the association.   Returns an unspecified value.</p>

<h4>
  <code>(hash-table-map-&gt;list </code><var>proc</var> <var>hash-table</var><code>)</code>
</h4>

<p>
Calls <var>proc</var> for every association in <var>hash-table</var>
with two arguments: the key of the association and the value of
the association.  The values returned by the invocations of
<var>proc</var> are accumulated into a list, which is returned.</p>

<h4>
  <code>(hash-table-fold </code><var>proc</var> <var>seed</var> <var>hash-table</var><code>)</code>
</h4>

<p>
Calls <var>proc</var> for every association in <var>hash-table</var>
with three arguments: the key of the association, the value of
the association, and an accumulated value <var>val</var>.
<var>Val</var> is <var>seed</var> for the first invocation of
<var>procedure</var>, and for subsequent invocations of <var>proc</var>,
the returned value of the previous invocation.  The value returned
by <code>hash-table-fold</code> is the return value of the last
invocation of <var>proc</var>.</p>

<p>
The <var>proc</var> is invoked for the associations in an unspecified
order. To fold over the associations in order, see the next entries.

<p>
<i>Rationale:</i> An implementation may be able to provide more
efficient iteration in an unspecified order than in insertion order
when the order is not significant for the <var>proc</var>.

<h4>
<code>(hash-table-fold-left </code><var>proc</var> <var>seed</var> <var>hash-table</var><code>)</code>
</h4>

<p>
Calls <var>proc</var> for every association in <var>hash-table</var>, in
order from oldest to newest, with three arguments: an accumulated
value <var>val</var>, the key of the association, and the value of the
association. <var>Val</var> is <var>seed</var> for the first invocation of
<var>procedure</var>, and for subsequent invocations of <var>proc</var>,
the returned value of the previous invocation. The value returned by
<code>hash-table-fold</code> is the return value of the last
invocation of <var>proc</var>.</p>

<h4>
<code>(hash-table-fold-right </code><var>proc</var> <var>seed</var> <var>hash-table</var><code>)</code>
</h4>

<p>
Calls <var>proc</var> for every association in <var>hash-table</var>, in
order from oldest to newest, with three arguments: the key of the
association, the value of the association, and an accumulated value
<var>val</var>. <var>Val</var> is <var>seed</var> for the first invocation
of <var>procedure</var>, and for subsequent invocations of
<var>proc</var>, the returned value of the previous invocation. The
value returned by <code>hash-table-fold</code> is the return value of
the last invocation of <var>proc</var>.</p>

<h4>
  <code>(hash-table-prune! </code><var>proc</var> <var>hash-table</var><code>)</code>
</h4>

<p>
Calls <var>proc</var> for every association in <var>hash-table</var>
with two arguments, the key and the value of the association, and
removes all associations from <var>hash-table</var> for which
<var>proc</var> returns true.  Returns the number of associations that were removed.</p>

<h3 id="Copyingandconversion">Copying and conversion</h3>

<h4>
  <code>(hash-table-copy </code><var>hash-table</var><code>)</code> <br>
  <code>(hash-table-copy </code><var>hash-table</var> <var>mutable?</var><code>)</code>
</h4>

<p>
Returns a newly allocated hash table with the same properties
and associations as <var>hash-table</var>. If the second argument
is present and is true, the new hash table is mutable.  Otherwise
it is immutable provided that the implementation supports immutable
hash tables.  (R6RS <code>hashtable-copy</code>)</p>

<h4>
  <code>(hash-table-empty-copy </code><var>hash-table</var><code>)</code>
</h4>

<p>
Returns a newly allocated mutable hash table with the same comparator
as <var>hash-table</var>, but with no associations. The implementation
may assume that the returned hash table will eventually contain as
many associations as does the original <var>hash-table</var>.</p>

<h4>
  <code>(hash-table-&gt;alist </code><var>hash-table</var><code>)</code>
</h4>

<p>
Returns an alist with the same associations as <var>hash-table</var>
in reverse insertion order.</p>

<h3 id="Hashtablesassets">Hash tables as sets</h3>

<h4>
<code>(hash-table-union! </code><var>hash-table</var><sub>1</sub> <var>hash-table</var><sub>2</sub><code>)</code></h4>

<p>
Adds the associations of <var>hash-table</var><sub>2</sub> to
<var>hash-table</var><sub>1</sub> and returns <var>hash-table<sub>1</sub></var>.
If a key appears in both hash tables, its value is set to the value
appearing in <var>hash-table</var><sub>1</sub>.  Returns
<var>hash-table</var><sub>1</sub>.</p>

<h4>
<code>(hash-table-intersection! </code><var>hash-table</var><sub>1</sub> <var>hash-table</var><sub>2</sub><code>)</code></h4>

<p>
Deletes the associations from <var>hash-table</var><sub>1</sub>
whose keys don't also appear in <var>hash-table</var><sub>2</sub> and
returns <var>hash-table<sub>1</sub></var>.</p>

<h4>
<code>(hash-table-difference! </code><var>hash-table</var><sub>1</sub> <var>hash-table</var><sub>2</sub><code>)</code></h4>

<p>
Deletes the associations of <var>hash-table</var><sub>1</sub> whose
keys are also present in <var>hash-table</var><sub>2</sub> and returns
<var>hash-table</var><sub>1</sub>.</p>

<h4>
<code>(hash-table-xor! </code><var>hash-table</var><sub>1</sub> <var>hash-table</var><sub>2</sub><code>)</code></h4>

<p>
Deletes the associations of <var>hash-table</var><sub>1</sub> whose
keys are also present in <var>hash-table</var><sub>2</sub>, and then
adds the associations of <var>hash-table</var><sub>2</sub> whose keys
are not present in <var>hash-table</var><sub>1</sub> to
<var>hash-table</var><sub>1</sub>. Returns <var>hash-table</var><sub>1</sub>.</p>

<h2 id="implementation">Implementation</h2>

<p>
The current sample implementation is unfinished, and is <a href="https://gitlab.com/dpk/presrfis/-/tree/master/srfi-125-ordered">here</a>.  When it is finished, it will be moved into <a href="https://github.com/scheme-requests-for-implementation/srfi-250">this SRFI's repo.</a><!-- in the code repository of this
SRFI. -->  It relies upon
<a href="https://srfi.schemers.org/srfi-128/">SRFI 128</a>.</p>

<h2 id="acknowledgements">Acknowledgements</h2>

<p>
  Some of the language of this SRFI is copied from SRFI 69 with thanks
  to its author, Panu Kalliokoski.  However, he is not responsible for
  what I have done with it.</p>

<p>I also acknowledge the members of the SRFI 250, 125, 126, and 128 mailing lists,
  especially Takashi Kato, Alex Shinn, Shiro Kawai, and Per Bothner.</p>

<h2 id="copyright">Copyright</h2>

<p>&copy; 2023 John Cowan, Will Clinger, Daphne Preston-Kendal.</p>

<p>
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  and/or sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:</p>

<p>
  The above copyright notice and this permission notice (including the
  next paragraph) shall be included in all copies or substantial
  portions of the Software.</p>

<p>
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.</p>

  <hr>
  <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>